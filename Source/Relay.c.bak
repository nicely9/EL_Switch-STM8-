/************************************************************************************
	Project		: 전자식스위치
	File Name	: RELAY.C
	Target		: EL_Switch
	Revision	: Rev 1.0
	Compiler	: ST Visual Develop(COSMIC)
	Date		: 2020/04/20
	Designed by	: J.S Yoon
	Modify		:
	Section		: NEO INFORMATION SYSTEMS CO.,LTD. R&D
************************************************************************************/

#include "header.h"
#include "eeprom.h"
#include "touch.h"
#include "el_switch.h"
#include "Relay.h"

#define	FLOATING_TMR	20		// 190~200ms

uint8_t	Gu8_LatchRelay_1_Floating_Tmr;
uint8_t	Gu8_LatchRelay_2_Floating_Tmr;

uint8_t	Gu8_RelayOnOff[MAX_RELAY];
//-------------------------------------------------------------------------------------------------------------------------
void Relay_Init(void)
{
	int i;
	
	/*
	if(GET_Switch_State(item2tsn(ctrl2item(CONTROL_BIT_RELAY_1))))
	{
		GPIO_Init(RELAY_1_PORT, RELAY_1_PIN, GPIO_Mode_Out_PP_High_Fast);	// Output push-pull, high level, 10MHz
	}
	else
	{
		GPIO_Init(RELAY_1_PORT, RELAY_1_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	}
	if(GET_Switch_State(item2tsn(ctrl2item(CONTROL_BIT_RELAY_2))))
	{
		GPIO_Init(RELAY_2_PORT, RELAY_2_PIN, GPIO_Mode_Out_PP_High_Fast);	// Output push-pull, high level, 10MHz
	}
	else
	{
		GPIO_Init(RELAY_2_PORT, RELAY_2_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	}
	if(GET_Switch_State(item2tsn(ctrl2item(CONTROL_BIT_RELAY_3))))
	{
		GPIO_Init(RELAY_3_PORT, RELAY_3_PIN, GPIO_Mode_Out_PP_High_Fast);	// Output push-pull, high level, 10MHz
	}
	else
	{
		GPIO_Init(RELAY_3_PORT, RELAY_3_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	}
	if(GET_Switch_State(item2tsn(ctrl2item(CONTROL_BIT_RELAY_4))))
	{
		GPIO_Init(RELAY_4_PORT, RELAY_4_PIN, GPIO_Mode_Out_PP_High_Fast);	// Output push-pull, high level, 10MHz
	}
	else
	{
		GPIO_Init(RELAY_4_PORT, RELAY_4_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	}
	*/
	
	GPIO_Init(RELAY_1_PORT, RELAY_1_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	GPIO_Init(RELAY_2_PORT, RELAY_2_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	GPIO_Init(RELAY_3_PORT, RELAY_3_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	GPIO_Init(RELAY_4_PORT, RELAY_4_PIN, GPIO_Mode_Out_PP_Low_Fast);	// Output push-pull, low level, 10MHz
	
	GPIO_Init(LATCH_RELAY_1_1_PORT, LATCH_RELAY_1_1_PIN, GPIO_Mode_Out_PP_Low_Fast);		// Output push-pull, low level, 10MHz
	GPIO_Init(LATCH_RELAY_1_2_PORT, LATCH_RELAY_1_2_PIN, GPIO_Mode_Out_PP_Low_Fast);		// Output push-pull, low level, 10MHz
	GPIO_Init(LATCH_RELAY_2_1_PORT, LATCH_RELAY_2_1_PIN, GPIO_Mode_Out_PP_Low_Fast);		// Output push-pull, low level, 10MHz
	GPIO_Init(LATCH_RELAY_2_2_PORT, LATCH_RELAY_2_2_PIN, GPIO_Mode_Out_PP_Low_Fast);		// Output push-pull, low level, 10MHz
	
	printf("Relay Init\n");
	
	Gu8_LatchRelay_1_Floating_Tmr	= 0;
	Gu8_LatchRelay_2_Floating_Tmr	= 0;
	
	for(i=0;i<MAX_RELAY;i++)
	{
		Gu8_RelayOnOff[i]	= 0;
	}
	//Relay_Ctrl(CONTROL_BIT_RELAY_LATCH_1 | CONTROL_BIT_RELAY_LATCH_2, OFF);		// 일단 최초전원 투입 후에는 꺼진것으로 설정
}

void Relay_Ctrl_Retry(void)
{
	if(Gu8_RelayOnOff[0])	GPIO_SetBits(RELAY_1_PORT, RELAY_1_PIN);
	else					GPIO_ResetBits(RELAY_1_PORT, RELAY_1_PIN);
	
	if(Gu8_RelayOnOff[1])	GPIO_SetBits(RELAY_2_PORT, RELAY_2_PIN);
	else					GPIO_ResetBits(RELAY_2_PORT, RELAY_2_PIN);
	
	if(Gu8_RelayOnOff[2])	GPIO_SetBits(RELAY_3_PORT, RELAY_3_PIN);
	else					GPIO_ResetBits(RELAY_3_PORT, RELAY_3_PIN);
	
	if(Gu8_RelayOnOff[3])	GPIO_SetBits(RELAY_4_PORT, RELAY_4_PIN);
	else					GPIO_ResetBits(RELAY_4_PORT, RELAY_4_PIN);
	
	if(Gu8_LatchRelay_1_Floating_Tmr)
	{
		if(Gu8_RelayOnOff[4])
		{
			GPIO_ResetBits(LATCH_RELAY_1_2_PORT, LATCH_RELAY_1_2_PIN);
			GPIO_SetBits(LATCH_RELAY_1_1_PORT, LATCH_RELAY_1_1_PIN);
		}
		else
		{
			GPIO_ResetBits(LATCH_RELAY_1_1_PORT, LATCH_RELAY_1_1_PIN);
			GPIO_SetBits(LATCH_RELAY_1_2_PORT, LATCH_RELAY_1_2_PIN);
		}
	}
	
	if(Gu8_LatchRelay_2_Floating_Tmr)
	{
		if(Gu8_RelayOnOff[5])
		{
			GPIO_ResetBits(LATCH_RELAY_2_2_PORT, LATCH_RELAY_2_2_PIN);
			GPIO_SetBits(LATCH_RELAY_2_1_PORT, LATCH_RELAY_2_1_PIN);
		}
		else
		{
			GPIO_ResetBits(LATCH_RELAY_2_1_PORT, LATCH_RELAY_2_1_PIN);
			GPIO_SetBits(LATCH_RELAY_2_2_PORT, LATCH_RELAY_2_2_PIN);
		}
	}
}

void Relay_Ctrl(uint8_t relay, uint8_t Flag)	// 전등
{
	uint8_t	item;
	
	if(relay&CONTROL_BIT_RELAY_1)
	{
		if(Flag == INVERSE)
		{
			item	= ctrl2item(CONTROL_BIT_RELAY_1);
			Flag	= (uint8_t)((~GET_Switch_State(item2tsn(item)))&0x01);
		}
		Gu8_RelayOnOff[0]	= Flag;
		if(Flag)	GPIO_SetBits(RELAY_1_PORT, RELAY_1_PIN);
		else		GPIO_ResetBits(RELAY_1_PORT, RELAY_1_PIN);
	}
	if(relay&CONTROL_BIT_RELAY_2)
	{
		if(Flag == INVERSE)
		{
			item	= ctrl2item(CONTROL_BIT_RELAY_2);
			Flag	= (uint8_t)((~GET_Switch_State(item2tsn(item)))&0x01);
		}
		Gu8_RelayOnOff[1]	= Flag;
		if(Flag)	GPIO_SetBits(RELAY_2_PORT, RELAY_2_PIN);
		else		GPIO_ResetBits(RELAY_2_PORT, RELAY_2_PIN);
	}
	if(relay&CONTROL_BIT_RELAY_3)
	{
		if(Flag == INVERSE)
		{
			item	= ctrl2item(CONTROL_BIT_RELAY_3);
			Flag	= (uint8_t)((~GET_Switch_State(item2tsn(item)))&0x01);
		}
		Gu8_RelayOnOff[2]	= Flag;
		if(Flag)	GPIO_SetBits(RELAY_3_PORT, RELAY_3_PIN);
		else		GPIO_ResetBits(RELAY_3_PORT, RELAY_3_PIN);
	}
	if(relay&CONTROL_BIT_RELAY_4)
	{
		if(Flag == INVERSE)
		{
			item	= ctrl2item(CONTROL_BIT_RELAY_4);
			Flag	= (uint8_t)((~GET_Switch_State(item2tsn(item)))&0x01);
		}
		Gu8_RelayOnOff[3]	= Flag;
		if(Flag)	GPIO_SetBits(RELAY_4_PORT, RELAY_4_PIN);
		else		GPIO_ResetBits(RELAY_4_PORT, RELAY_4_PIN);
	}
	if(relay&CONTROL_BIT_RELAY_LATCH_1)
	{
		if(Flag == INVERSE)
		{
			item	= ctrl2item(CONTROL_BIT_RELAY_LATCH_1);
			Flag	= (uint8_t)((~GET_Switch_State(item2tsn(item)))&0x01);
		}
		Gu8_RelayOnOff[4]	= Flag;
		//Gu8_LatchRelay_1_Floating_Tmr	= 5;	// 40~50ms
		Gu8_LatchRelay_1_Floating_Tmr	= FLOATING_TMR;	// 90~100ms	// jsyoon 20200925
		//printf("L\n");	// TEST
		if(Flag)
		{
			//printf("1\n");	// TEST
			GPIO_ResetBits(LATCH_RELAY_1_2_PORT, LATCH_RELAY_1_2_PIN);
			GPIO_SetBits(LATCH_RELAY_1_1_PORT, LATCH_RELAY_1_1_PIN);
		}
		else
		{
			//printf("2\n");	// TEST
			GPIO_ResetBits(LATCH_RELAY_1_1_PORT, LATCH_RELAY_1_1_PIN);
			GPIO_SetBits(LATCH_RELAY_1_2_PORT, LATCH_RELAY_1_2_PIN);
		}
	}
	if(relay&CONTROL_BIT_RELAY_LATCH_2)
	{
		if(Flag == INVERSE)
		{
			item	= ctrl2item(CONTROL_BIT_RELAY_LATCH_2);
			Flag	= (uint8_t)((~GET_Switch_State(item2tsn(item)))&0x01);
		}
		Gu8_RelayOnOff[5]	= Flag;
		//Gu8_LatchRelay_2_Floating_Tmr	= 5;	// 40~50ms
		Gu8_LatchRelay_2_Floating_Tmr	= FLOATING_TMR;	// 90~100ms	// jsyoon 20200925
		//printf("K");	// TEST
		if(Flag)
		{
			//printf("3\n");	// TEST
			GPIO_ResetBits(LATCH_RELAY_2_2_PORT, LATCH_RELAY_2_2_PIN);
			GPIO_SetBits(LATCH_RELAY_2_1_PORT, LATCH_RELAY_2_1_PIN);
		}
		else
		{
			//printf("4\n");	// TEST
			GPIO_ResetBits(LATCH_RELAY_2_1_PORT, LATCH_RELAY_2_1_PIN);
			GPIO_SetBits(LATCH_RELAY_2_2_PORT, LATCH_RELAY_2_2_PIN);
		}
	}
	//printf("E\n\n");	// TEST
}
